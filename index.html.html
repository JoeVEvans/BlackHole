<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>The Singularity</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; user-select: none; }
        
        #hud {
            position: absolute; bottom: 30px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 20px;
            pointer-events: none;
        }

        .hint-box {
            background: rgba(0,0,0,0.6); padding: 10px 20px; border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.15);
            color: rgba(255,255,255,0.7); font-family: sans-serif; font-size: 13px;
            text-align: center;
            backdrop-filter: blur(4px);
        }

        .highlight { color: #ffaa00; font-weight: bold; }
    </style>
    
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="hud">
        <div class="hint-box">
            <span class="highlight">MOUSE</span> Drag to Orbit / Scroll to Zoom
        </div>
        <div class="hint-box">
            <span class="highlight">WASD</span> to Pan View
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { AfterimagePass } from 'three/addons/postprocessing/AfterimagePass.js';

        const CONFIG = {
            count: 150000,          
            radiusEH: 25,
            diskOuter: 180,
            starCount: 15000
        };

        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 4000);
        camera.position.set(0, 50, 320);

        const renderer = new THREE.WebGLRenderer({ antialias: false, powerPreference: "high-performance" });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5));
        document.body.appendChild(renderer.domElement);

        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.enablePan = true;
        controls.minDistance = 30;
        controls.maxDistance = 2000;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.1;
        controls.addEventListener('start', () => { controls.autoRotate = false; });

        const keys = { w: false, a: false, s: false, d: false };
        window.addEventListener('keydown', (e) => { if(keys.hasOwnProperty(e.key)) keys[e.key] = true; });
        window.addEventListener('keyup', (e) => { if(keys.hasOwnProperty(e.key)) keys[e.key] = false; });

        // --- 1. THE PHOTON RING SHADER (New) ---
        // This replaces the basic black material.
        const blackHoleShader = {
            vertexShader: `
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                void main() {
                    vNormal = normalize(normalMatrix * normal);
                    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                    vViewPosition = -mvPosition.xyz;
                    gl_Position = projectionMatrix * mvPosition;
                }
            `,
            fragmentShader: `
                varying vec3 vNormal;
                varying vec3 vViewPosition;
                
                void main() {
                    // Fresnel Effect: Calculate angle between surface normal and camera view
                    vec3 normal = normalize(vNormal);
                    vec3 viewDir = normalize(vViewPosition);
                    float dotProduct = dot(normal, viewDir);
                    
                    // We want the edge (dotProduct near 0.0) to glow
                    // Invert dot product
                    float rim = 1.0 - max(dotProduct, 0.0);
                    
                    // Sharpen the rim to be razor thin
                    rim = pow(rim, 6.0); 

                    // Color the rim white/blue
                    vec3 rimColor = vec3(0.6, 0.8, 1.0) * rim * 2.0;

                    // The core is black
                    gl_FragColor = vec4(rimColor, 1.0);
                }
            `
        };

        // --- 2. PARTICLE SHADERS (Existing) ---
        const particleVertex = `
            uniform float time;
            uniform vec3 camPos; 
            attribute float size;
            attribute float speed;
            attribute float angleOffset;
            attribute float radius;
            attribute float yOffset;
            attribute vec3 customColor;
            attribute float randomSeed; 
            varying vec3 vColor;

            void main() {
                float t = time * 0.2; 
                float currentAngle = angleOffset - (t * speed) + (20.0 / radius);
                float twist = 800.0 / radius; 
                float finalAngle = currentAngle + twist;
                float noise = sin(finalAngle * 10.0 + randomSeed * 50.0) * 0.5;
                float r = radius + noise;
                float currentY = yOffset * (r / 100.0);
                vec3 pos = vec3(cos(finalAngle) * r, currentY, sin(finalAngle) * r);
                
                vec3 velocityDir = normalize(vec3(-sin(finalAngle), 0.0, cos(finalAngle)));
                vec3 viewDir = normalize(camPos - pos);
                float doppler = dot(velocityDir, viewDir);

                vec3 finalColor = customColor;
                if(doppler > 0.0) finalColor = mix(finalColor, vec3(1.0), doppler * 0.35); 
                else finalColor = finalColor * (1.0 + doppler * 0.5); 
                
                float edgeFade = smoothstep(180.0, 150.0, r);
                float innerFade = smoothstep(25.0, 26.0, r);
                vColor = finalColor * edgeFade * innerFade;
                
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_PointSize = size * (350.0 / -mvPosition.z);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const particleFragment = `
            varying vec3 vColor;
            void main() {
                vec2 uv = gl_PointCoord.xy - 0.5;
                float dist = length(uv);
                if (dist > 0.5) discard;
                float strength = 1.0 - (dist * 2.0);
                strength = pow(strength, 2.5); 
                gl_FragColor = vec4(vColor, strength);
            }
        `;

        // --- BUILD DISKS ---
        function createDisk(isHalo) {
            const geometry = new THREE.BufferGeometry();
            const count = isHalo ? CONFIG.count * 0.3 : CONFIG.count;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const speeds = new Float32Array(count);
            const angleOffsets = new Float32Array(count);
            const radii = new Float32Array(count);
            const yOffsets = new Float32Array(count);
            const randomSeeds = new Float32Array(count);

            const colDeep = new THREE.Color(0x550000); 
            const colMid = new THREE.Color(0xff5500);  
            const colBright = new THREE.Color(0xffaa22); 

            for (let i = 0; i < count; i++) {
                const r = CONFIG.radiusEH + Math.pow(Math.random(), 2.0) * (CONFIG.diskOuter - CONFIG.radiusEH);
                const theta = Math.random() * Math.PI * 2;
                const thickness = 1.0 + (r * 0.1); 
                const y = (Math.random() - 0.5) * thickness;

                positions[i*3] = 0; 
                radii[i] = r;
                angleOffsets[i] = theta;
                yOffsets[i] = y;
                randomSeeds[i] = Math.random(); 
                sizes[i] = 0.5 + Math.random() * 2.0;
                speeds[i] = (80.0 / (r)) * 0.2 + Math.random() * 0.05;

                const alpha = (r - CONFIG.radiusEH) / (CONFIG.diskOuter - CONFIG.radiusEH);
                let c;
                if (alpha < 0.2) c = colBright.clone().lerp(colMid, alpha * 5);
                else c = colMid.clone().lerp(colDeep, (alpha - 0.2) * 1.25);
                if(isHalo) c.lerp(new THREE.Color(0x88ccff), 0.2);

                colors[i*3] = c.r; colors[i*3+1] = c.g; colors[i*3+2] = c.b;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('speed', new THREE.BufferAttribute(speeds, 1));
            geometry.setAttribute('angleOffset', new THREE.BufferAttribute(angleOffsets, 1));
            geometry.setAttribute('radius', new THREE.BufferAttribute(radii, 1));
            geometry.setAttribute('yOffset', new THREE.BufferAttribute(yOffsets, 1));
            geometry.setAttribute('randomSeed', new THREE.BufferAttribute(randomSeeds, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: { time: { value: 0 }, camPos: { value: new THREE.Vector3() } },
                vertexShader: particleVertex,
                fragmentShader: particleFragment,
                transparent: true, depthWrite: false, blending: THREE.AdditiveBlending, opacity: 1.0
            });

            const mesh = new THREE.Points(geometry, material);
            mesh.frustumCulled = false;
            if (isHalo) { mesh.rotation.x = Math.PI / 2; mesh.scale.set(1.0, 0.9, 1.0); }
            return mesh;
        }

        const mainDisk = createDisk(false);
        scene.add(mainDisk);
        const haloDisk = createDisk(true);
        scene.add(haloDisk);

        // --- APPLY PHOTON RING SHADER ---
        const holeGeo = new THREE.SphereGeometry(CONFIG.radiusEH, 128, 128); // Higher poly for smooth edge
        const holeMat = new THREE.ShaderMaterial({
            vertexShader: blackHoleShader.vertexShader,
            fragmentShader: blackHoleShader.fragmentShader
        });
        const blackHole = new THREE.Mesh(holeGeo, holeMat);
        scene.add(blackHole);

        // --- STARS ---
        const sGeo = new THREE.BufferGeometry();
        const sPos = [];
        for(let i=0; i<CONFIG.starCount; i++) {
            const r = 800 + Math.random() * 1200;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            sPos.push(r * Math.sin(phi)*Math.cos(theta), r*Math.sin(phi)*Math.sin(theta), r*Math.cos(phi));
        }
        sGeo.setAttribute('position', new THREE.Float32BufferAttribute(sPos, 3));
        const starMat = new THREE.PointsMaterial({color:0x666666, size: 1.0, transparent:true});
        scene.add(new THREE.Points(sGeo, starMat));

        // --- POST PROCESSING ---
        const composer = new EffectComposer(renderer);
        composer.addPass(new RenderPass(scene, camera));
        
        const afterimage = new AfterimagePass();
        afterimage.uniforms['damp'].value = 0.92; 
        composer.addPass(afterimage);

        const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
        bloom.strength = 1.2; bloom.radius = 0.5;
        composer.addPass(bloom);

        // --- ANIMATION ---
        const clock = new THREE.Clock();
        const panVector = new THREE.Vector3();

        function animate() {
            requestAnimationFrame(animate);
            const dt = clock.getDelta();
            const time = clock.getElapsedTime();
            
            mainDisk.material.uniforms.time.value = time;
            haloDisk.material.uniforms.time.value = time;
            mainDisk.material.uniforms.camPos.value.copy(camera.position);
            haloDisk.material.uniforms.camPos.value.copy(camera.position);

            // Halo Lensing Opacity Calc
            haloDisk.lookAt(camera.position);
            let viewAngle = Math.abs(camera.position.y / camera.position.length());
            let visibility = 1.0 - viewAngle;
            visibility = Math.pow(visibility, 2.0); 
            haloDisk.material.opacity = visibility * 0.5;

            // Pan
            const panSpeed = 100 * dt;
            panVector.set(0, 0, 0);
            if (keys.w) panVector.y += panSpeed;
            if (keys.s) panVector.y -= panSpeed;
            if (keys.a) panVector.x -= panSpeed;
            if (keys.d) panVector.x += panSpeed;

            if (panVector.lengthSq() > 0) {
                controls.autoRotate = false;
                panVector.applyQuaternion(camera.quaternion);
                camera.position.add(panVector);
                controls.target.add(panVector);
            }

            controls.update();
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        animate();
    </script>
</body>
</html>